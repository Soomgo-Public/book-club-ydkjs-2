## 📚 읽은 내용
  ~p.52


- 이전 이야기 : `this는 호출부에서 함수 호출시 바인딩 된다`

### 1️⃣ 너무 웃겨서 이건 적어야해
- `시인 김춘수의 꽃` : 그의 이름을 불러 주기 전에는 그는 다만 하나의 몸짓에 지나지 않았다.
- 이런 문학적인 비유 너무 좋아..
- 이것이 바로 this의 비유법

### 2️⃣ 기본 바인딩
- 전역 변수 a 선언, 호출된 함수(foo) 내부에서 this.a 호출 : 전역 변수 a를 호출하였기에 정상적인 동작
- "useStrict" 자주 쓰일까? typescript에서는 본적 있다
- 역시나 이후에 나온 내용 : 서드 파티 라이브러리에서의 호환성 이슈 주의깊게 볼것

### 3️⃣ 암시적 바인딩
- obj객체에서 this로 호출하는 함수를 프로퍼티로 참조할 때
- 함수 레퍼런스에대한 콘텍스트 객체가 존재할때 암시적 바인딩 규칙에 따르면,

   이 콘텍스트 객체가 함수 호출시 this에 바인딩 된다.

어렵다.. 코드 가져와보자
```javascript
functlon foo() { 
    // 3. this.a는 2
    console.log( this.a );
}

// 2. objs는 this 
var obj = {
    a: 2,
    foo: foo 
}

// 1. 함수 호출시
obj.foo(); // 2![img.png](img.png)

// 4. 따라서 2 가 return
```

- 체이닝 호출시, 중간단계는 무시되고 마지막 호출된 함수가 this로 바인딩 된다

### 4️⃣ 암시적 소실
this 바인딩이 뜻밖에 헷갈리기 쉬운 경우? 
-> 엄격 모드 여부에 따라 전역 객체나 undefined 중 한가지로 기본 바인딩 된다. (뭐야 억울해)
- 유명 js 라이브러리의 이벤트 처리기에서 dom요소 강제 지칭은 매우 혼잡한 사용법이라했다.. :감히 추측컨대 요것은 jQuery ..!?


- -> 호출부가 여기저기 존재한다면 this를 호출한 부분에 포함인지 소유인지 여부를 따지기에 복잡성이 늘어난다. 
따라서 this의 의미가 모호해진다. 

이를 해결하기 위해 this를 고정하는 방법은 바로

### 5️⃣ 명시적 바인딩
- call & apply : 대부분의 js 메소드에 내장되어있음. 객체대신 단순 원시값을 전달하면, 원시 값에 대응되는 객체로 리팽 된다. 
 
### 6️⃣ 하드 바인딩
- ..




## 📚 느낀점
- 


## 📚 공유하고 싶은 부분(사이트)
